## Context

目前 `main.go` 中，`cmd.Execute()` 被呼叫後，無論結果如何（幫助、正常執行或錯誤），程式都會執行 `drawLogo()` 並輸出 gopher ASCII art。當使用者僅想查看幫助時（`-h` 或 `--help`），這會造成不必要的延遲。

問題根源在於 `main()` 無法判斷 `Execute()` 是否已處理了幫助訊息，因此無法決定是否跳過圖像繪製。

## Goals / Non-Goals

**Goals:**
- 修改 `Execute()` 函式，使其能回報是否顯示過幫助訊息
- 在 `main()` 中根據返回值決定是否執行 `drawLogo()`
- 保持現有命令邏輯不變，不影響其他功能

**Non-Goals:**
- 不修改幫助訊息的內容或格式
- 不更改其他命令的執行流程
- 不涉及 TUI 介面的行為

## Decisions

### 決策 1：`Execute()` 返回值的設計

**決策**：讓 `Execute()` 返回 `bool` 型別，`true` 表示應繼續執行（繪製圖像），`false` 表示幫助已被顯示（跳過圖像）

**理由**：
- 簡單直觀：一個布爾值清楚表達意圖
- 最小侵入：只需修改兩個檔案（`cmd/root_cmd.go` 和 `main.go`）
- 易於測試：易於驗證返回值的正確性

**替代方案**：
- 使用 error code 或 exit code — 過於複雜，且容易與實際錯誤混淆
- 設定全域旗標 — 違反設計原則，增加狀態管理複雜性

### 決策 2：判斷幫助是否被顯示

**決策**：通過檢查 `rootCmd.ExecuteC()` 返回的命令物件，判斷是否為幫助命令（或幫助被隱式觸發）

**理由**：
- Cobra 提供 `ExecuteC()` 方法，回傳執行的命令物件
- 幫助命令通常名稱為 "help" 或可通過檢查 flag 判斷（`cmd.Flag("help")`）
- 避免侵入式修改，符合現有架構

**替代方案**：
- 檢查 `os.Args` — 不夠可靠，無法處理 Cobra 的複雜邏輯
- 設定回呼函式 — 過度設計

## Risks / Trade-offs

| 風險 | 緩解方案 |
|------|---------|
| **幫助判斷遺漏** — 某些邊界情況下無法正確判斷幫助是否被顯示 | 在實作時充分測試各種 flag 組合（`-h`, `--help`, `hermes help` 等） |
| **向後兼容性** — 改變 `Execute()` 返回值 | 此函式為內部使用，不影響外部 API |
| **複雜性** — 增加判斷邏輯 | 邏輯簡單清晰，維護成本低 |
